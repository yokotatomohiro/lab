量子アニーリングを用いた効率的な組み合わせ最適化

absoract
量子コンピュータが市販され, ヒュリスティックにNP困難問題に取り組めるようになったが, 現在の量子コンピュータが古典的コンピュータよりも量子的優位性があるものを提供しているかは分からない.
この論文ではNP困難問題である, クリーク検出と, グラフ分割に対するD-Wave2X量子アニーラの性能を評価する.
そのために量子アニーラに適したQUBOおよびイジングハミルトニアンとして定式化して, テストセットに対して量子ソルバ(Sapi,QBSolv,QSage)と古典的アルゴリズム(METES,SA,3rd)との性能を比較する.

実験の結果, グラフサイズが小さい場合, 得られた最良の解の質は同程度であったが, 古典的な方法は計算時間の点で量子アニーラよりも優れていた.
また, D-Waveに埋め込むことができる問題サイズに制限かあるので, 量子アニーラで解ける問題のほとんどでこれが当てはまる.
しかし, D-Waveの構造に合うように特別に設計された問題に対しては, 古典的な方法よりも計算時間が大幅に速くなる.

/-----------------------------------
1. Introduction
/-----------------------------------

最大クリーク問題とは, 与えられたグラフに対するフルコネクトのようなサブセットを見つけることを問題としている.
グラフ分割は, グラフをあらかじめ指定された数の成分に分割するために, 切る辺の数を最小にする.
このグラフ分割ではもう一つの変形であるCH分割を利用する.

量子アニーラは古典的なシミュレーテッドアニーリングのアルゴリズムをハードウェアとして実現したものであるが, 低エネルギー配置を探すために量子ゆらぎを利用している.

問題をハミルトニアンの形式にし, 最小化するために量子コンピュータを利用する利点は, 問題を物理システムに写像することで, システムがどのようにエネルギー最小値に自信を配置したかを観察することで解を読み取ることができることである.
特に, 計算時間は問題の大きさと無関係である.

記事の構成について
二章では, QUBOとイジングハミルトニアンの紹介をし, D-Waveの構造について説明する. 
また, 実験で利用する量子ツール(Sepi,QBSolv,QSage)や古典的アルゴリズム(SA,METHIS,Gurobi)について説明する.

三章では, 最大クリーク問題について調べる.
問題をQUBOで定式化し, 最大クリーク問題を解くために使用するパラメータについて説明する.
また, 小さいグラフと, 量子ビット構造に適合するように特別に選択されたグラフとの比較実験を示す.

四章では, エッジ分割とCH分割の二種類のグラフ分割に焦点を当てる.
QUBOとイジングの両方でハミルトニアンを導出し, ハミルトニアンの重みに関する条件を説明する.
ランダムグラフを使用して, エッジ分割とCH分割の両方について, 計算時間と求められた分割の質の観点から, 古典的ソルバと量子ソルバを評価する.
D-Waveデバイスの埋め込みにかかる時間とアニール時間を比較する.

五章では, 実験結果についての議論をする.
そこでは, D-Waveチップに合わせた問題に対しては量子的優位性が観測できたが, 一般的な問題に対しては観測できないと主張している.

/-----------------------------------
2. Method
/-----------------------------------
この章ではD-Waveデバイスが解ける問題である二次整数計画法について説明する.

2.1 Ising and QUBO formulations
(式)
二次整数計画法はn個の変数q_{i}を操作することで
QUBOの定式化では変数は{0,1}の二値を取り, イジングの定式化では{-1,+1}を取る.

慣例として, QUBOの問題では重みは下側対角行列として記述されており, 対角成分が一次の重みと対応し, 非対角成分は二次の重みに対応している.
イジング問題では一次の重みをベクトルhとして与え, 二次の重みを下対角行列で表す.

2.2 Conversion of Ising to QUBO and vice versa
QUBOとイジングは等価であり, 二つの違いは変数の取りうる値だけである.
以下のようにして変換をすることが可能である.

2.3 Qubit architecture and chains of qubits
D-Waveの量子コンピュータの量子ビットは12セルの格子状に相互接続された4×4の二部グラフセルからなるチップ上のキメラグラフ構造で配置されている.


2.4 D-Wave solver
D-Wave Inc.はいくつかの量子ソルバを提供しており, 量子ソルバは問題を量子コンピュータに提出し, 返された解に対して必要な後処理を適用して出力する.

2.4.1 Sepi 
C++およびPython用のインターフェースであり, これはD-Waveサーバへのインターネット接続の確立, 二次計画法の提出, および, 解の後処理を行える.
重要なことに, SepiインターフェースはユーザがD-Waveパラメータをユーザ自身が調節できる.
調節できるものに, 量子デバイスが実行することになっている繰り返し回数の選択, 後処理のタイプ指定, キメラ物理グラフ構造への埋め込み計算がある.
ユーザは埋め込みグラフを完全に制御できるので, キメラ構造に完全に適合するように設計された二次計画を提供することができる.
任意のグラフのサイズは48頂点に制限される.

2.4.2 QBSolve


2.4.3 QSage
C++およびPythonコードの中でD-Waveサーバへの接続ができるプログラミングインタフェースである.
SepiやQBSolvとは異なり, QUBOやイジングの定式化を必要としないブラックボッックスソルバである.

代わりに, QSageは　目的ブラックボックスからランダムな点をサンプリングし, それにより得られる関数値を利用して二次計画を補間して, その二次計画をD-Waveに送信する.
D-Waveから返された最小にを初期値としてタブーサーチを行う.

2.5 Classical solvers
古典的なソルバについての説明

2.5.1 simulated annealing with random staritng point
シミュレーテッドアルゴリズムについての説明

温度関数としてT(t)=log(1+t)を使用する.

2.5.2 METIS and Simulated annealing
METISは次の三段階のアプローチに基づいてグラフ分割を行うヒューリスティックなアルゴリズムである.

手順１
  力グラフを, 元のグラフG=G_{0}から始まり, 適切に小さいグラフG_{n}(典型的には100頂点未満)で終わる一連のグラフG_{0},...,G_{n}を    生成することで荒くしていく. 
  このシーケンスはi<Jの場合には常にG_{i}がG_{j}よりも少ないノードを含むという特性を持つ. 
  
手順２
  G_{n}はスペクトル二等分法またはk方向分割など, 他の選択したアルゴリズムを使用して分割される. 
  
手順３
  分割はG_{n-1},...,G_{1}を介してG_{0},...,G_{n}に逆投影される. 
  粗密化段階のより細かいグラフのそれぞれはマルチノードグラフよりも多くの自由度を含むので, 各投影後の分割を向上させるために, Fiduccia-Mattheysesのような改良アルゴリズムが使用される. 
  
METISを使用することで, サブグラフのサイズ, 区分化アルゴリズムなどを変更できる.
METISはグラフ分割で採用し, CH分割では, METISで与えられる初期解をりようしてSAで解く.

2.5.3 Gurobi
数学的プログラミングソルバである.
Gurobiは特定のQUBO問題を解くために使用した.

/-----------------------------------
3. The maximum clique problem
/-----------------------------------

最大クリーク問題は多くの分野で利用されている有名なNP困難問題である.
無向グラフを考えると, 定式化は非常に簡単である.
クリークは完全なサブクラスを形成する頂点のサブセットsとなる.sは完全グラフとなる.
クリークのサイズはsの頂点数であり, 最大クリーク問題はGの最大可能クリークを見つけることである.

先行研究ではクリーク問題を解くために量子断熱進化を利用していた.
しかし, 当時はD-Wave2Xを利用できなかったので先行研究では小さなグラフに限定されていた.
その結果では二乗の実行時間がかかるようであるように見えた.
今回の実験では可能であれば, 実際のD-Waveにのせてこの仮説を大きなグラフ上で検証する.

3.2 QUBO formulation 
先行研究ではクリーク問題は次のように定式化できる.

サイズKのクリークが存在する場合, 基底状態ではH=0になる.
次に, この式にグラフ内の最大クリークを見つけるための変数を追加する.
ただし, 完全グラフ上にN=|V|個の変数が必要である.
最大独立集合(MIS)問題から導出される単純な定式化が望ましい.

グラフGの独立した集合は頂点の集合であり, ここで二つの頂点ごとにGの辺が接続されることはない.
補集合グラフHでは, 独立したGの集合がクリークであることが簡単に分かる.
したがって, Gの最大クリークを探すことと, Hの最大独立集合を探すことは同じである.
グラフH上のMIS問題のQUBO定式化は簡単で, 頂点iが独立集合にある場合は1, そうでない場合は0となる.
辺に対するペナルティは, 頂点に対するボーナスよりも大きくなければならない.
したがって, グラフGのMIS問題に対するQUBOは次のようになる.
(式)
この定式化では|V|個の変数と|E|個の二次項が必要である.
これにより, 非常に密なグラフで最大クリーク問題を解くことが簡単になった.

3.3 Method
D-Wave2Xに理論上埋め込める最大のグラフは49頂点であり, 製造時の量子ビットの欠落からわずかに小さい45頂点である.
よって, D-Wave2Xで確実に解ける最大のグラフは45頂点のグラフである.
したがって, 任意のグラフでMIS問題を解くためには, 最初の入力グラフを最大でも45頂点の小さなグラフに分割する分割統治法を行う必要がある.

3.3.1 Sapi parameters
Sapiは量子アニーラの最低レベルの制御である.
3.4.2節での実験では全４５頂点のグラフの事前計算された埋め込みを使用する.

3.4 Results
3.4.1 Software solvers
D-Wave2Xでの結果を様々なソルバでの結果と比較した.
イジング問題に対して動作するシミュレーテッドアニーリング, クリーク問題を解くために特別に設計されたシミュレーテッドアニーリングアルゴリズム, ヒューリスティックまたは厳密にクリークを見つけるために設計されたソフトフェア(fmc)とGurobiソルバ.
D-Waveの後処理をするヒューリスティックなアルゴリズムのみから得られた結果も比較に含める.

SA-ising:
イジング問題に対して作用するシミュレーテッドアニーリングアルゴリズムである.
初期解はランダムであり, シミュレーテッドアルゴリズム内の単一の動きは1ビット反転である.

SA-clique:
このアルゴリズムは特定のサイズmのクリークを見つけるように設計されている.

Fast Max-Clique Finder(fmc):
これは大きなスパースグラフに対して最大クリークを効率的に見つけるために設計されたアルゴリズムである.

Post-Processing Heuristics alone(PPHa):
D-Waveのパイプラインには後処理ステップが含まれている.
パイプラインから出てくる特定の解について, D-Wave2Xシステムと後処理ステップの相対的な貢献について考える.
小さくて単純な問題に対しては, 後処理ステップだけで良い解を見つけられるかもしれない.

3.4.2 Results
小さなグラフに対しての結果: 最初に45頂点を持つグラフに対する量子アニーラの振る舞いを調べた.

500頂点で密度が増加するランダムグラフに対してグラフ分割法を行う.
生成されるグラフの密度は0.1から0.4にする.
図1はこの実験の結果を示し, 各データ点は, 10回の実行結果の中央値であり, エラーソルバは標準偏差を示してる.
ソルバの呼び出し数は, 入力グラフの密度に関する指数関数曲線に従う.

二番目の実験では, ににの大きさのグラフに対するクリーク発見アプローチに対する将来世代のD-Waveシステムの影響を測定する.
図2では量子ビットの増加数に対するソルバコール数の展開を表している.
この実験では, グラフサイズは500頂点で固定し, 辺の存在確率は0.3に固定されている.
各データ点は, 10回の実行結果の中央値であり, エラーソルバは標準偏差を示してる.
量子ビットの数が新世代ごとに倍になっていることを考えると

3.4.3 Artificial graph designed to fit chimera
ここでの考えは, D-Wave2Xが可能な限り最高のシナリオで達成できるスピードを確認することである.
この可能な限り最良のシナリオは, キメラグラフすなわち非常に少数の連鎖を必要とするグラフであり, うまくいけばMIS問題が自明でないグラフである.

グラフ生成
キメラグラフはD-Wave2Xシステムが解ける最も密な1100頂点のグラフである.

キメラグラフの作成方法について説明

これはキメラグラフ
キメラグラフの作成方法について説明
キメラグラフの作成方法について説

実験

/-----------------------------------
4. Method
/-----------------------------------



/-----------------------------------
5. Method
/-----------------------------------




