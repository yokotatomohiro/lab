量子アニーリングを用いた効率的な組み合わせ最適化

absoract
量子コンピュータが市販され, ヒュリスティックにNP困難問題に取り組めるようになったが, 現在の量子コンピュータが古典的コンピュータよりも量子的優位性があるものを提供しているかは分からない.
この論文ではNP困難問題である, クリーク検出と, グラフ分割に対するD-Wave2X量子アニーラの性能を評価する.
そのために量子アニーラに適したQUBOおよびイジングハミルトニアンとして定式化して, テストセットに対して量子ソルバ(Sapi,QBSolv,QSage)と古典的アルゴリズム(METES,SA,3rd)との性能を比較する.

実験の結果, グラフサイズが小さい場合, 得られた最良の解の質は同程度であったが, 古典的な方法は計算時間の点で量子アニーラよりも優れていた.
また, D-Waveに埋め込むことができる問題サイズに制限かあるので, 量子アニーラで解ける問題のほとんどでこれが当てはまる.
しかし, D-Waveの構造に合うように特別に設計された問題に対しては, 古典的な方法よりも計算時間が大幅に速くなる.

/-----------------------------------
1. Introduction
/-----------------------------------

最大クリーク問題とは, 与えられたグラフに対するフルコネクトのようなサブセットを見つけることを問題としている.
グラフ分割は, グラフをあらかじめ指定された数の成分に分割するために, 切る辺の数を最小にする.
このグラフ分割ではもう一つの変形であるCH分割を利用する.

量子アニーラは古典的なシミュレーテッドアニーリングのアルゴリズムをハードウェアとして実現したものであるが, 低エネルギー配置を探すために量子ゆらぎを利用している.

問題をハミルトニアンの形式にし, 最小化するために量子コンピュータを利用する利点は, 問題を物理システムに写像することで, システムがどのようにエネルギー最小値に自信を配置したかを観察することで解を読み取ることができることである.
特に, 計算時間は問題の大きさと無関係である.

記事の構成について
二章では, QUBOとイジングハミルトニアンの紹介をし, D-Waveの構造について説明する. 
また, 実験で利用する量子ツール(Sepi,QBSolv,QSage)や古典的アルゴリズム(SA,METHIS,Gurobi)について説明する.

三章では, 最大クリーク問題について調べる.
問題をQUBOで定式化し, 最大クリーク問題を解くために使用するパラメータについて説明する.
また, 小さいグラフと, 量子ビット構造に適合するように特別に選択されたグラフとの比較実験を示す.

四章では, エッジ分割とCH分割の二種類のグラフ分割に焦点を当てる.
QUBOとイジングの両方でハミルトニアンを導出し, ハミルトニアンの重みに関する条件を説明する.
ランダムグラフを使用して, エッジ分割とCH分割の両方について, 計算時間と求められた分割の質の観点から, 古典的ソルバと量子ソルバを評価する.
D-Waveデバイスの埋め込みにかかる時間とアニール時間を比較する.

五章では, 実験結果についての議論をする.
そこでは, D-Waveチップに合わせた問題に対しては量子的優位性が観測できたが, 一般的な問題に対しては観測できないと主張している.

/-----------------------------------
2. Method
/-----------------------------------
この章ではD-Waveデバイスが解ける問題である二次整数計画法について説明する.

2.1 Ising and QUBO formulations
(式)
二次整数計画法はn個の変数q_{i}を操作することで
QUBOの定式化では変数は{0,1}の二値を取り, イジングの定式化では{-1,+1}を取る.

慣例として, QUBOの問題では重みは下側対角行列として記述されており, 対角成分が一次の重みと対応し, 非対角成分は二次の重みに対応している.
イジング問題では一次の重みをベクトルhとして与え, 二次の重みを下対角行列で表す.

2.2 Conversion of Ising to QUBO and vice versa
QUBOとイジングは等価であり, 二つの違いは変数の取りうる値だけである.
以下のようにして変換をすることが可能である.

2.3 Qubit architecture and chains of qubits
D-Waveの量子コンピュータの量子ビットは12セルの格子状に相互接続された4×4の二部グラフセルからなるチップ上のキメラグラフ構造で配置されている.


2.4 D-Wave solver
D-Wave Inc.はいくつかの量子ソルバを提供しており, 量子ソルバは問題を量子コンピュータに提出し, 返された解に対して必要な後処理を適用して出力する.

2.4.1 Sepi 
C++およびPython用のインターフェースであり, これはD-Waveサーバへのインターネット接続の確立, 二次計画法の提出, および, 解の後処理を行える.
重要なことに, SepiインターフェースはユーザがD-Waveパラメータをユーザ自身が調節できる.
調節できるものに, 量子デバイスが実行することになっている繰り返し回数の選択, 後処理のタイプ指定, キメラ物理グラフ構造への埋め込み計算がある.
ユーザは埋め込みグラフを完全に制御できるので, キメラ構造に完全に適合するように設計された二次計画を提供することができる.
任意のグラフのサイズは48頂点に制限される.

2.4.2 QBSolve


2.4.3 QSage
C++およびPythonコードの中でD-Waveサーバへの接続ができるプログラミングインタフェースである.
SepiやQBSolvとは異なり, QUBOやイジングの定式化を必要としないブラックボッックスソルバである.

代わりに, QSageは　目的ブラックボックスからランダムな点をサンプリングし, それにより得られる関数値を利用して二次計画を補間して, その二次計画をD-Waveに送信する.
D-Waveから返された最小にを初期値としてタブーサーチを行う.

2.5 Classical solvers
古典的なソルバについての説明

2.5.1 simulated annealing with random staritng point
シミュレーテッドアルゴリズムについての説明

温度関数としてT(t)=log(1+t)を使用する.

2.5.2 METIS and Simulated annealing
METISは次の三段階のアプローチに基づいてグラフ分割を行うヒューリスティックなアルゴリズムである.

手順１
  力グラフを, 元のグラフG=G_{0}から始まり, 適切に小さいグラフG_{n}(典型的には100頂点未満)で終わる一連のグラフG_{0},...,G_{n}を    生成することで荒くしていく. 
  このシーケンスはi<Jの場合には常にG_{i}がG_{j}よりも少ないノードを含むという特性を持つ. 
  
手順２
  G_{n}はスペクトル二等分法またはk方向分割など, 他の選択したアルゴリズムを使用して分割される. 
  
手順３
  分割はG_{n-1},...,G_{1}を介してG_{0},...,G_{n}に逆投影される. 
  粗密化段階のより細かいグラフのそれぞれはマルチノードグラフよりも多くの自由度を含むので, 各投影後の分割を向上させるために, Fiduccia-Mattheysesのような改良アルゴリズムが使用される. 
  
METISを使用することで, サブグラフのサイズ, 区分化アルゴリズムなどを変更できる.
METISはグラフ分割で採用し, CH分割では, METISで与えられる初期解をりようしてSAで解く.

2.5.3 Gurobi
数学的プログラミングソルバである.
Gurobiは特定のQUBO問題を解くために使用した.

/-----------------------------------
3. The maximum clique problem
/-----------------------------------

最大クリーク問題は多くの分野で利用されている有名なNP困難問題である.
無向グラフを考えると, 定式化は非常に簡単である.
クリークは完全なサブクラスを形成する頂点のサブセットsとなる.sは完全グラフとなる.
クリークのサイズはsの頂点数であり, 最大クリーク問題はGの最大可能クリークを見つけることである.

先行研究ではクリーク問題を解くために量子断熱進化を利用していた.
しかし, 当時はD-Wave2Xを利用できなかったので先行研究では小さなグラフに限定されていた.
その結果では二乗の実行時間がかかるようであるように見えた.
今回の実験では可能であれば, 実際のD-Waveにのせてこの仮説を大きなグラフ上で検証する.

3.2 QUBO formulation 
先行研究ではクリーク問題は次のように定式化できる.

サイズKのクリークが存在する場合, 基底状態ではH=0になる.
次に, この式にグラフ内の最大クリークを見つけるための変数を追加する.
ただし, 完全グラフ上にN=|V|個の変数が必要である.
最大独立集合(MIS)問題から導出される単純な定式化が望ましい.

グラフGの独立した集合は頂点の集合であり, ここで二つの頂点ごとにGの辺が接続されることはない.
補集合グラフHでは, 独立したGの集合がクリークであることが簡単に分かる.
したがって, Gの最大クリークを探すことと, Hの最大独立集合を探すことは同じである.
グラフH上のMIS問題のQUBO定式化は簡単で, 頂点iが独立集合にある場合は1, そうでない場合は0となる.
辺に対するペナルティは, 頂点に対するボーナスよりも大きくなければならない.
したがって, グラフGのMIS問題に対するQUBOは次のようになる.
(式)
この定式化では|V|個の変数と|E|個の二次項が必要である.
これにより, 非常に密なグラフで最大クリーク問題を解くことが簡単になった.

3.3 Method
D-Wave2Xに理論上埋め込める最大のグラフは49頂点であり, 製造時の量子ビットの欠落からわずかに小さい45頂点である.
よって, D-Wave2Xで確実に解ける最大のグラフは45頂点のグラフである.
したがって, 任意のグラフでMIS問題を解くためには, 最初の入力グラフを最大でも45頂点の小さなグラフに分割する分割統治法を行う必要がある.

3.3.1 Sapi parameters
Sapiは量子アニーラの最低レベルの制御である.
3.4.2節での実験では全４５頂点のグラフの事前計算された埋め込みを使用する.

3.4 Results
3.4.1 Software solvers
D-Wave2Xでの結果を様々なソルバでの結果と比較した.
イジング問題に対して動作するシミュレーテッドアニーリング, クリーク問題を解くために特別に設計されたシミュレーテッドアニーリングアルゴリズム, ヒューリスティックまたは厳密にクリークを見つけるために設計されたソフトフェア(fmc)とGurobiソルバ.
D-Waveの後処理をするヒューリスティックなアルゴリズムのみから得られた結果も比較に含める.

SA-ising:
イジング問題に対して作用するシミュレーテッドアニーリングアルゴリズムである.
初期解はランダムであり, シミュレーテッドアルゴリズム内の単一の動きは1ビット反転である.

SA-clique:
このアルゴリズムは特定のサイズmのクリークを見つけるように設計されている.

Fast Max-Clique Finder(fmc):
これは大きなスパースグラフに対して最大クリークを効率的に見つけるために設計されたアルゴリズムである.

Post-Processing Heuristics alone(PPHa):
D-Waveのパイプラインには後処理ステップが含まれている.
パイプラインから出てくる特定の解について, D-Wave2Xシステムと後処理ステップの相対的な貢献について考える.
小さくて単純な問題に対しては, 後処理ステップだけで良い解を見つけられるかもしれない.

3.4.2 Results
小さなグラフに対しての結果: 最初に45頂点を持つグラフに対する量子アニーラの振る舞いを調べた.

500頂点で密度が増加するランダムグラフに対してグラフ分割法を行う.
生成されるグラフの密度は0.1から0.4にする.
図1はこの実験の結果を示し, 各データ点は, 10回の実行結果の中央値であり, エラーソルバは標準偏差を示してる.
ソルバの呼び出し数は, 入力グラフの密度に関する指数関数曲線に従う.

二番目の実験では, ににの大きさのグラフに対するクリーク発見アプローチに対する将来世代のD-Waveシステムの影響を測定する.
図2では量子ビットの増加数に対するソルバコール数の展開を表している.
この実験では, グラフサイズは500頂点で固定し, 辺の存在確率は0.3に固定されている.
各データ点は, 10回の実行結果の中央値であり, エラーソルバは標準偏差を示してる.
量子ビットの数が新世代ごとに倍になっていることを考えると

3.4.3 Artificial graph designed to fit chimera
ここでの考えは, D-Wave2Xが可能な限り最高のシナリオで達成できるスピードを確認することである.
この可能な限り最良のシナリオは, キメラグラフすなわち非常に少数の連鎖を必要とするグラフであり, うまくいけばMIS問題が自明でないグラフである.

グラフ生成
キメラグラフはD-Wave2Xシステムが解ける最も密な1100頂点のグラフである.

キメラグラフの作成方法について説明

これはキメラグラフはキメラに埋め込むことができ解き方が自明ではないMIS問題に対する最良のグラフである.

実験
D-Wava2XのSapi,PPHaおよび, SA-Isingソフトウェアを利用してこのMIS問題を解く.
SA-cliqueとfmcを使用して, 補グラフの等価な最大クリーク問題を解く.
その結果は図3のようになる.

グラフサイズ400までは, PPHaはD-Waveと同じ結果になる.
これらの小さなグラフでは, 問題はおそらく後処理ステップだけで解けるほど簡単である. 
想定通り, クリークように特別に設計されたシミュレーテッドアニーリングはSAイジングよりも良好に動作している.
fmcソフトフェアはヒューリスティックモードで実行されている.
これは大規模な疎グラフ用に設計されており, ここでは非常に密集したグラフ上で実行されている.これがおそらく比較的低品質の低い結果の理由である.

大きなグラフ(頂点が800を超える)の場合は, D-Wave 2Xが最良の解を提供する.
それが最適な解であるかどうかはわからない.

スピードを上げる.
SAクリークはD-Wave 2Xと比較するのに最適な候補であると思われるので, このC_{m}群のグラフでSAクリークと比較してD-Wave 2Xの速度を計算することにした. 
手順は以下のようになる.
各グラフサイズごとに, 500回のアニールでD-Wave 2Xを実行し, 最良の解を報告する.
D-Wave 2Xランタイムは500アニール, つまり約0.15秒の合計qpuランタイムである.
SAクリークについては, 低いαパラメータ(すなわち急速冷却スケジュール)から初めて, SAクリークがD-Wave2Xと同じ解を見つけるまで徐々にαを増加させる.
SAクリークが同じ解を見つけたこのαは, SAクリークに最良の実行結果を与える.
SAクリークアルゴリズムは次のようなCPUで動かしている.
図4は異なるグラフサイズ(C_{m}群)に対するスピードアップを示している.
頂点数が200以下の小さなグラフに対してはD-Wave2Xは遅いが, 大きなグラフに対しては, 指数関数的に速くなり, 最大で百万のスピードアップになる.

これはD-Wave2Xの最良のシナリオであり, ランダムグラフで得られるものを代表するものではないが, これはD-Wave2Xシステムにおける量子的振る舞いを示す証拠になる可能性がある.
D-Wave2Xは, 我々が試した全ての古典的なソルバでは得ることが非常に難しい解を非常に速く見つけることができる.

/-----------------------------------
4. Graph partitioning
/-----------------------------------

この章ではグラフ分割のための様々な方法を調べる.
グラフ分割問題には二つの種類がある.
エッジカット分割とコアハロ分割である.

4.1 Hamiltonian formulations
4.1.1 Ising model for graph partitioning
先行研究では標準的なエッジカット分割をするためのイジングハミルトニアンを与える.
しかし, 定式化はグラフを二つの要素に分割すること適している.

エッジカット分割は, 異なる区画に属する頂点を結ぶ辺が最小になるようにグラフを分割することを目的としている.

論文では二つの区画をイジングスピンが+か-かでどちらの区画に属しているかを表現している.

上記では, H_{A}は両方のパーティションで頂点の均等なバランスを強制するペナルティ項である.
偶数の頂点を仮定すると, H_{A}は, 両方のパーティションの頂点の数が等しい場合に限り, ゼロになる.
奇数の頂点に対しては, H_{A}は１以上になる.
H_{B}は目的関数である.
これは, 同じ区画にはなくエッジカットと等しい二つの頂点を結ぶ辺に対して1のペナルティを加える.
したがって, Hを最小にすると, グラフのエッジカット分割が最小になる.

目的関数H_{B}のさらなる減少を達成するために, H_{A}に違反することが決して有利でないように, 重みAおよびBは入力グラフに応じて選択しなくてはならない.
この目的のために, 目的関数の減少を最大にしながら, 所与の変化に対するペナルティの最小の増加を決定することで十分である.
Hの極小値(均衡状態)でのs_{v}の配置を考える.
簡単にするために, 一般性を失うことなく, 頂点の数が等しと仮定する. つまりH_{A}=0と仮定する.

以下, 重みA,Bの大きさについての詳細な説明.

4.1.2 A generalisation to partitioning into multiple parts
上記の定式化では任意の数の区画に分割することができないので, できるように一般化する.
このために, s_{vi} \in {0,1}を頂点vが区画iに属しているかどうかを符号化するバイナリ(QUBO)指標とする.
Kを所望する分割数とする.
ハミルトニアンを次のように定義する. H=AH_{A} + B_{B} + CH_{C}
(式)
上記の定式化の背景にある推論は以下の通りである.
H_{A}は, 各頂点vがちょうど一つの区画にのみ属する場合, つまり各v\in Vに対して一つのk_{v}しか存在しない場合, (s_{v},k_{v}=1)に限りゼロになる.
\sum{s_{vk}}は区画kのサイズなので, H_{B}は等しいサイズ|V|/Kの分割を強制する.
H_{C}は目的関数の項である.
これは二つの頂点u,vが同じ区画に属するように動機付けする. つまり, s_{uk}=s_{vk}=1(区画kの場合)で, 区画間のエッジカットが最小になる.

以下, 重みの設定についての詳細な説明.

4.1.3 Qubo model for CH-partitioning
標準的なエッジカット分割とは別に, 論文で紹介されているCH分割と呼ばれる特別なグラフ分割について説明する.
CH分割では, 各区画内の頂点の数c_{i}(コア)の和(二乗)が次のように, 頂点VをK個の集合(分割)に分割, 各区画i \in {1,...,K}と他の区画内の隣接する頂点の数h_{i}(ハロー)を最小化することを目指す.
(式2)
この問題のハミルトニアンを設計するためにHを考えると次の式のようになる.
(式)
そしてN(v)は頂点vの全ての隣接する集合を意味する.
二つのタイプの指標を使って, 頂点が与えられた区画にいる(コア)いないか(ハロー)をエンコードする.
各変数c_{vi}は, 頂点vが区画(コア)iに属す値を１とコーディングするバイナリ(qubo)インジエータである.
同様に, ハローインジケータはh_{vi}である.
補助変数z_{(v,w),i}はグラフ内の各辺(v,w)と各区画iは解釈なしである.
それらの, ペナルティH_{B}が均衡状態で値0をとることを確実にするために使用される.

上記の定式化の背後にある理論は次の通りである.
各頂点は4.1.2節で述べたようにただ一つのコアにのみ属し, 各頂点vに対してc_{v1},...,c_{vi}の区画の内の一つが1の値を持つ.
これは, 各頂点vに対してc_{vi}=1となるようなiがただ一つ存在する場合に限り, H_{A}を0にすることで, これが強制される.

さらに, CH分割問題の定義によって, 頂点vは, 頂点vと区画jのコアである頂点wを結ぶ辺がグラフ上にある場合に限り, 区画jのハロに属している.
この定義を拡張し, vがコアjの一部である場合, またはvをコアj内の頂点に接続する辺がある場合, vを区画jのハロの頂点になるように定義する.
これはH_{B}で強制されている.
頂点vと区画番号iが与えられたとすると(H_{B}の二番目のsum), h_{vi}はvの全ての隣接頂点wに対して, c_{vi}=1またはc_{wi}=1となるときはいつでも１となる. 
当然, 区画iにおける頂点vの隣接頂点はh_{vi}=1となる. 
したがって, h_{vi}はwが与えられたときc_{wi}=0になる場合でも1を取る. したがって, 均衡状態でもペナルティが0にならないようにする.
変数z_{(v,w),i}を導入することでこれを補正する. 後者の場合, 変数は1を取り, 均衡状態でH_{B}=0であることが確認できる.
与えられたv,wに対してh_{vi}-c_{wi}=0が当てはまる場合, これがハミルトニアンの全体的な値を増加させるので, z_{(v,w),i}を1にするインセンティブはない.

CH分割において, 最小化されることが求められる目的関数はあ, コアノードとハロノードの二乗和である.
上記の定義から, vがコアまたはハロの頂点であるならば, h_{vi}=1となるので(\sum)^2を最小化するには十分である. 

以下

/-----------------------------------
5. Method
/-----------------------------------




