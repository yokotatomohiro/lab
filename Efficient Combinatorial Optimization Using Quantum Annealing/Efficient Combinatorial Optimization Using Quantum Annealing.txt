量子アニーリングを用いた効率的な組合せ最適化

abstract
最初に市販された量子コンピュータは, 現在の技術を用いてヒューリスティックにNP困難な問題に取り組むツールを提供した. 
しかし, 現在の量子コンピュータが古典的なコンピュータよりも量子的優位性があるものをすでに提供しているかは不明です. 
この記事では, 二つのNP困難のグラフ問題, 特にクラーク検出とグラブ分割に対するD-Wave 2X量子アニーラの性能を評価する. 
このために, 量子アニーラに適したQUBOおよびIsingハミルトニアンとしての定式化を提供し, あるグラフのテストセットに対して様々な量子ソルバー(Sapi, QBSolve, D-waveが提供するQSage)と現在の古典的アルゴリズム(METIS, シミュレーテッドアニーリング, 3rd)との性能を比較する. 
グラフのサイズが小さい場合, 得られた最良の解の質は同程度であるにもかかわらず, 古典的な方法は依然として計算時間の点で量子アニーラよりも優れていた. 
それにもかかわらず, D-Wave 2Xチップに埋め込むことが問題サイズに制限があるために, 前述した発見は量子アニーラで解けるほとんどの問題に当てはまる. 
D-Wave 2Xアーキテクテャに合うように特別に設計された例では, 古典的は方法よりも計算時間が大幅に早くなる. 

1. Introduction 
最初の商用的量子コンピュータの利用可能性は, コンピューティング, 物理学およびアルゴリズム設計の分野において新たな多くの挑戦をもたらした. 
特に新しい装置は, 現在の技術をヒューリスティックに用いることでのみ解けるNP困難な問題を解くことができるツールを提供する. 
だが, 利用可能な量子コンピュータが実際に古典的な方法を超える利点を提供できるかどうかは依然として論争されている. 

この記事では, 二つのNP困難のグラフ問題(最大クリーク検出および分割(エッジカットおよびch-))についてD-Wave2X量子コンピュタの性能を調べる. 
第一の問題は, 与えられたグラフに対するフルコネクトのようなサブセットを見つけることを問題としている. 
後者は通常, 全ての成分間のエッジ数が最小になるように, グラフをあらかじめ指定された数の成分に分割することを目的としている. 
この記事で調べたグラフの分割のもう一つの変形はcore-halo(CH)分割です. 

様々な古典的な発見方法が両方の問題を妥当な時間内で高精度に解くことが知られている. 
異なるアプローチに従うものがD-Wave Systems Inc.が開発した量子アニーラである. 
簡単に言えは, 量子アニーラは古典的なシミュレーテッドアニーリングのアルゴリズムをハードウェアとして実現したものだが, エネルギーもしくは目的関数のランドスケープを探すために量子効果を利用するという例外がある. 
シミュレーテッドアニーリングで提案されたランダム移動と同様に, 量子アニーラでは局所最適解を回避し, 物理システムの低エネルギー配置を見出すために回避量子揺らぎを利用している. 
量子ビット(qubit)は, D-Waveチップ上の一連の超伝導ループを介して実現される. 
各ルーブは, アニーリングが完了してシステムが古典的になるまで時計回りおよび反時計回りの両方向に二つの重畳電流を介して同時に0および1ビットの両方に符号化する. 

D-Waveチップの特定の成分により, このデバイスは与えられた定数によって重み付けられた線形および二次量子ビット寄与の合計からなる制約のない目的関数を最小化するように設計されている. 
正確には次のハミルトニアンを最小化することを目的としている. 

(式)

aは実数, Vは集合, Eは空間
上記形式のハミルトニアンを最小化するために量子コンピュータを使う利点は, 古典的には組み合わせ問題はNP困難であるが, その問題を物理システムに写像することによって, システムがどのようにエネルギー最小値にそれ自身を配置したかを観察することによって解を読み取ることができる. 
特に, 計算時間は問題の大きさと無関係であり, 基本的に決定論的な既存のデジタルコンピュータとは異なり, 量子アニーリングは基本的には確率的です. そのため最小化の手順は実験的性質より, 解は常に同一ではない. 

この記事は次のように構成されている. 二章ではQUBO(二次無制限二値最適化)とIsingハミルトニアンの紹介をし, D-Waveのアーキテクチャについて説明する. 
さらに, 量子ツール(Sepi, QBsolv, Qsage）を, この研究で利用する古典的なアルゴリズム(シミュレーテッドアニーリング, METIS, Gurobi)と同様に記述する. 

三章では最大クリーク問題を調べる. 
QUBOの定式化, グラフ分割アルゴリズムおよびD-Waveで最大クリーク問題を解くために使用するパラメータについて説明する. 
さらに三章では, 小さいグラブとD-Waveの量子ビットアーキテクチャに適合するように特別に選択されたグラフとの比較研究を示す. 
比較は古典的な方法(量子断熱進化, 特殊なシミュレーテッドアニーリング), fmcクリークヒューリスティックおよび厳密ソルバー, Gurobi)およびD-Waveによって提供されている前述のソルバーを含む.

四章では, エッジ分割とCH分割と呼ばれる二種類のグラフ分割に焦点を当てる. 
これはQUBOとIsingの両方の公式でハミルトニアンを導き出し, 最適な分割解でハミルトニアンの大域的最小値が達成されることを保証するハミルトニアンの重みに関する条件を証明する. 
ランダムグラフを使用して, 四章ではエッジカットとCH分割問題の両方について, 計算時間と計算された分割の質の観点から, 前述した全ての古典的ソルバと量子ソルバを評価する. 
D-Waveデバイスの埋め込み時間とアニール時間を比較する. 

最後に五章では結果の議論をまとめ, 量子的優位性はD-Waveチップに合わせた場合のみ観測できるが, 一般形式の問題の場合には観測できないと主張している. 

本項では, G=(V, E)はグラフを意味し, Vはn個の頂点の集合を意味し, Eは無向辺の集合を意味している. 
集合Vの基数を|V|として表現する. 

2. Methods
この章ではD-Waveデバイスが解ける問題である二次整数計画法を紹介する. 
このような二次プログラムの二つの異なる定式化を提供し, 二つの間での変換方法を示す. 
次に, この章では二次計画法を量子コンピュータに提出するためにD-Wave.Incが提供する三つのツールについて簡単に説明する. 
そのために, 入力フォーマット, 使用されるソルバーとそのインターフェース, そして利用可能な後処理方法と出力フォーマットを扱う. 

2.1 Ising and QUBO formulations
D-Waveデバイスは, 二次整数計画法と呼ばれる問題のみを解くように設計されている. 
それはn個の変数q_{i}, i\in {1,\dots , n}を操作することで, 線形および二次相互作用を可能にし, 総和は次の式のようになる. 

(式1)

a_{i}は実数であり線形の重みであり, a_{ij}は実数であり二体の重みを表し事前に利用者によって設定される. 
前述した二次最小化計画法には二つの種類がある. 
QUBOの定式化では, 全ての変数はq_{i}={0,1}の二値を取り, Ising定式化ではq_{i}={-1,1}を取る. 
どちらの定式化でも, (式1)の二次計画法の項は変化しない. 

慣例として, QUBO問題は文献においてしばしば重みQ_{i,j}は下側(または上側)対角行列として述べられている. ここで, 対角成分は線形の重みと対応し, 非対角成分は二次結合と対応する. 
Ising問題では線形の重みをベクトルhとして与え, 下側(または上側)対角行列J_{ij}(i<j(i>j))で表す.

2.2 Conversion of Ising to QUBO and vice versa
QUBOとIsingの二次整数計画法は等価である. 二つの違いは変数q_{i}の取りうる値だけであり, それゆえに一つの公式を他の公式に変換することが可能である. 
これは次のようにして行われる. 

線形重みQ_{ii}と二次重みQ_{ij}(i<j)を持つQUBO問題が与えられたとする.
この時, 次のように設定することで等価なIsing問題となる.

(式)

同様にして, 線形重みのベクトルhとカプラ行列JをもつIsing問題を次のように定義することでQUBO問題へと変換できる. 

2.3 Qubit architecture and chains of qubits
D-Waveの量子コンピュータは, 特定のグラフアーキテクチャ上に配置された約1,000量子ビットを操作する. 
利用可能な量子ビットの正確な数は製造誤差によりチップごとに異なる. つまり, 想定される量子ビットの数がデバイスごとにわずかに少ないことを意味する. 
量子ビットは12セルの格子状に相互接続された4×4の二部グラフセルからなるチップ上のキメラグラフアーキテクチャで配置されている. 

量子ビットの特定のアーキテクチャは二つの重要なことを意味している. 
一つは　チップ設計が二つの量子ビットのペアワイズ寄与を可能にしている. 
線形寄与と一緒に, これは目的関数の形式をD-Waveで解くことができる(式1)の二次整数計画法として動機づけている. 

二つ目は, 理論的には(式1)は任意の二つの量子ビットq_{i}, q_{j}の間にはペアワイズ相互作用を含むが, これは実際には当てはまらない. 
D-Waveチップ上の物理的量子ビットはいずれも4×4の二部グラフセル内でのみ辺を持っており, さらに, おそらく隣接セルの量子ビットへさらに接続するので, 対相互作用は実際には非常に制限される. 
したがって, 実際には関連する二つの量子ビットが物理チップ上にすでに隣接していない場合には, QUBOまたはIsing入力問題で指定されたペアワイズ相互作用を様々な量子ビットを通して再ルーティングしなければならない. 
物理チップ上で実際に隣接していない二つのビットq_{i},q_{j}を接続するために使用されるこれらの追加量子ビットはチェーンと呼ばれる. 

チェーンの存在は三章, 四章で重要な役割を果たす二つの重要な結果をもたらす. 
一方で, チェーンの必要性は二次計画法で利用可能であろう量子ビットを使い果たしてしまう. つまり, 多くのベアワイズ相互作用を含む問題では, 約1,000量子ビット以下しか利用できない. 
完全グラフの最悪の場合では, 任意のペアワイズカプラが望まれる時(式1)では48量子ビットしか利用できない. 
一方で, 量子アニーリングプロセスの確率的性質のために, D-Waveによって返される解は必ずしも同一ではない. 
チェーン内の全ての量子ビットは構成によって(式1)の同じ単一ビットを符号化するのでどの解決法でも一貫した値を取るべきであるので, これは特定の場合に使用される全てのチェーンにとって問題である. 
この現象は ,チェーンの破れと呼ばれている. 
もしチェーンが壊れた場合には特定の量子ビットにどの値が割り当てられているかは明確ではないので, 後処理技術が必要になる. 
当然ながら, 利用者が解きたい二次計画よりも高いカプラ重みを割り当てることで, チェーンが破損しないようにすることができる. 
しかし, この場合, 量子アニーラは実際の二次計画法のいくつかのカプラを侵害するという犠牲を払うことで, 全てのチェーンが満たされる(すなわち, 一つの一貫した値を有する)ことを保証するように暗黙的に調整され, 実行不可能な解決策につながる. 
満足のいくチェーンを保証することと, ユーザが解きたい実際の二次計画に十分な重みを置くことの間にはトレードオフの関係があり, さらなる研究が必要である. 

2.4 D-Wave solver
D-Wave Inc.は(式1)で与えられたインスタンスを実装するためのいくつかのソルバを提供しており, ソルバは量子コンピュータに提出し, それが返す解に必要な後処理手順を適用し出力をフォーマットする. 
この章ではこの論文で利用したD-Waveコンピュータへのインタフェースについて説明する. 

2.4.1 Sepi
C++およびpython用のインタフェースはD-Wave Inc.によって提供されている. 
これらのインターフェースはD-Waveサーバへのインターネット接続の確立, IsingおよびQUBO形式での二次計画法の提出, および, 解の後処理を可能にする. 

最も重要なことに, sepiインターフェースはユーザーがD-Waveパラメータを自分で調節できることがある. 
これは, 量子デバイスが実行することになっている繰り返し回数を選択, 後処理のタイプ指定, キメラ物理グラフ構造へのIsingまたはQUBOの個々の埋め込み計算を可能にする. 
二次計画法自体は適切なデータ構造のベクトル(線形重みを含む)および行列(二次重みを含む)として提供され, 解はユーザーが適切と見なす方法で評価または処理できるベクトルとして返される. 
IsingとQUBOの両方の公式を解くためのsepiルーチンがあるが, Isingルーチンの方がより上手くいくように思われることに気がついた. 
同等のIsing式とQUBO式の間で変換するためのsepiルーチンが提供されているので, これは問題にはならない. 

ユーザは埋め込みグラフを完全に制御するので, キメラアーキテクチャに完全に適合するように設計された二次計画を提供することができる.
任意のグラフは48頂点(量子ピット)に制限され, これはペアワイズ相互作用が全て存在する場合でもキメラグラフに埋め込むことができる最大グラフである. 

要約すると, sepiインターフェースはD-Waveシステムの最低レベルの制御を提供し, 量子アニーラに直接取り組むための最良の候補である. 

2.4.2 QBsolv
QBsolvは, D-Waveパラメータの面倒をみて, 問題を自動的に埋め込むことを目的とした高水準ツールである. 
これはプログラミングインタフェースではなく, 選択されたコンピュータアーキテクチャ用のスタンドアローンバイナリによって提供されている. 

QBsolvはQUBOの問題のみを解く. 
ユーザは最初に線形重みを, その後に二次カプラを列挙する特定のフォーマットでQUBOを提供する. ここで, 各二次カプラQ_{ij}について ,i<jを満たす. 

特に, QBsolvに提出されるインスタンスサイズに制限がない. 
それらは自動的にサブ問題に分割されてD-Waveへ提出され, 全てのD-Waveでの解の後処理に対して広範囲のタブーサーチが適用される. 
QBsolvではさらに, 個々の解の試行回数, D-Waveに収まらないインスタンスを分割するために使用される部分問題サイズ, 求められるハミルトニアンの目標値, またはタイムアウトパラメータなどの特定のパラメータを指定することができる. 

解は, 端末に表示されるか, または出力ファイルに書き込まれるかであり, そこからさらに処理するために解を再読み込みする必要がある. 

2.4.3 Qsage
QSageはC++とPythonコードの中でD-Waveサーバへの接続を可能にするもう一つのプログラミングインタフェースである. 
SepiやQBsolvとは対照的に, QUBOやIsingの定式化を必要としないブラックボックスソルバである. 

代わりに, QSageは任意のサイズのバイナリ入力文字列を操作することで一次元関数を最小化することができる. 
この目的のために, QSageは目的ブラックボックスからランダムな点を内部的にサンプリングし、それにより得られた関数値を利用して二次計画を補間し, それがD-Waveに送信される. 
D-Waveによって返された最小値は, 目的関数の最小値の代用とし, それを初期点としてタブーサーチまたは目的関数のさらなる展開に使用される. 
QSageは目的関数が滑らかである必要はないが, 当然ながら, 滑らかな関数に対して最良の結果が得られる. 

2.5 Classical solvers
D-Wave Inc.が提供するツールとは別に, 比較のために古典的なソルバを使用する. 
この章ではそのソルバについて説明する. 

2.5.1  Simulated annealing with random starting point
シミュレーテッドアニーリング(SA)は広く利用される最適化アルゴリズムである. 
点ごとの評価のみを使用して, 実質的に全ての目的関数を最小化(最大化)するための効果的な方法を提供する.

SAは既存の解への一連のランダム移動(修正)を提案することで目的関数を繰り返し最小化する. 
これらの動きは, ユーザが指定する分布にしたがってランダムに描かれる. 
アルゴリズムに極小値を回避する能力を与えるために, 現在見出されていす最良の解をさらに最小化しない修正は必ずしも拒絶されるわけではなく, ある許容確率で許容される. 
この許容確率は, 目的関数の(好ましくない)増加の大きさに比例し, 実行時間に反比例する. 
後者は, SAを実行の開始時に目的関数のランドスケープを探索しながら, 時間の経過とともに徐々に最急降下アルゴリズムに変えるという特性を与える. 
許容確率を実行時間に反比例して依存させるために, いわゆる温度関数が使用される. 
これはゼロへの減少関数である. 
SAは(今回の実験で利用したように)一定の反復回数, 特定の反復回数についてより良い解が見つからなくなるまで, または温度が消失するほど小さくなるまでなど様々な停止基準で実行できる. 

アルゴリズム1はイジングハミルトニアン(4.1.1章)によって与えられるグラフ分割インスタンスを解くために適用されたSAの実装を示す. 
一般的な温度関数T(t)=log(1+t)を使用する. 

2.5.2 METIS and Simulated Annealing
METISは三段階のアプローチに基づいてグラフ分割を実行するための一般的なヒューリスティックマルチレベルアルゴリズムである. 

METISのアルゴリズム
1. 入力グラフを, 元のグラフG=G_{0}から始まり, 適切に小さいグラフG_{n}(典型的には100頂点未満)で終わる一連のグラフG_{0},...,G_{n}を生成することで荒くしていく. 
このシーケンスはi<Jの場合には常にG_{i}がG_{j}よりも少ないノードを含むという特性を持つ. 

2. G_{n}はスペクトル二等分法またはk方向分割など, 他の選択したアルゴリズムを使用して分割される. 

3. 分割はG_{n-1},...,G_{1}を介してG_{0},...,G_{n}に逆投影される. 
粗密化段階のより細かいグラフのそれぞれはマルチノードグラフよりも多くの自由度を含むので, 各投影後の分割を向上させるために, Fiduccia-Mattheysesのような改良アルゴリズムが使用される. 

MEITSを使用すると, ユーザはいくつかのパラメータ, 例えばサブグラフG_{n}のサイズ, 粗調整, または区分化アルゴリズムを変更できる. 

二つの方法でMETISを採用している. 
まず最初に, 与えられたグラフのエッジカット分割を計算し(4.1.1章と4.1.2章), その分割をcore-halo(CH-)分割の出発点として使用することを4.1.3節で調べた. 

CH分割について, 論文では異なる測定基準に関してさらに最適化するために, 与えられた分割を改良することができるSAに基づくアルゴリズムを提供した. 
四章ではH分割が求められるので, METISが提供する初期解を用いてSAを利用する. 

2.5.3 Gurobi
Gurobiは線形計画法, 混合整数線形計画法および二次計画法, ならびに特定の二次計画法のための数学的プログラミングソルバである. 

特定のQUBO問題を解くためにGurobiを使用する. (Ising問題も同様に解くことができるが, Gurobiは変数の範囲をバイナリ入力に明示的に制限することを可能にし, QUBOインスタンスに対して特に適したものである.)
そのため, 与えられたQUBOを利用し, Gurobi形式で二次計画を出力する単純なコンバーターをプログラムした. 

3 The maximum clique problem

3.1 Introduction 
最大クリーク問題は, ソーシャルネットワーク, バイオインフォマティクス, データマイニング, および他の多くの分野で利用されている有名なNP困難問題である. 
無向グラフG=(V,E)を考えると, その定式化は非常に簡単であり, クリークは完全なサブグラフを形成する頂点のサブセットSとなる. すなわち, Sの二つの頂点ごとにGの辺によって接続される. 
クリークのサイズはSの頂点数であり, 最大クリーク問題はGの最大可能クリークを見つけることである. 

先行研究ではクリーク問題を解くために量子断熱進化の利用について調べていた. 
しかし, 当時はD-Wave2Xシルテムは利用できず, そのため研究は小さなグラフに限定されていた(n \leq 18)
その結果は, 量子アルゴリズムは二次実行時間のみを必要であるように見えたようだった. 
可能であれば, 実際のD-Wave2Xシステム上のその仮定をもっと大きなグラフ上で検証する. 

3.2 QUBO formulation 
QUBOは次のように書ける. x_{i}は{0,1}の二値変数であり, Q_{ij}(i\neq j)は二次項であり, Q_{ii}は線形項である. 
A.Lucasの論文はクリーク問題のQUBO定式化を提供している. 

(式)

サイズKのクリークが存在する場合, 基底状態はH=0になる. 
次に, グラフ内の最大クリークを見つけるために変数を追加する. 
ただし, この定式化では, (K-\sum)^{2}項がQUBO式の全ての可能な二次項を生成するので, 完全グラフ上にN=|V|個の変数が必要である. 
最大独立集合(MIS)問題から導出される単純な定式化が好ましい. 

グラフGの独立した集合は頂点の集合であり, ここで二つの頂点ごとにGの辺が接続されることはない. 
補集合グラフH=(C,\overline{E})では, 独立したG=(V,E)の集合がクリークであることが簡単にわかる. ここで\overline{E}はGのは存在しない辺の集合である. 
したがって, Gの最大クリークを探すことと, Hの最大独立集合を探すことは同じである. 
グラフH上のMIS問題のQUBO定式化は簡単で, 頂点iが独立集合にある場合はx_{i}=1, そうでない場合はx_{i}=0となる. 
この集合内のつ夏の頂点がグラフ内の辺によって接続されてる場合にはペナルティがあるはずであり, したがって, グラフHの全ての既存の辺に対して, 正の二次項Mが必要である. 
最大の独立集合が必要である. つまり線形項の負の重みLが必要である. 
辺に対するペナルティは, 頂点に対するボーナスよりも大きくなければならないので, L=-1, M=2のように単一の辺を持つ頂点を集合に追加することは有害である. 
したがって, グラフG=(V,E)のMIS問題に対するQUBOは次の式のようになる. 

(式)

この定式化には, |V|個の変数と|E|個の二次項が必要である. 
この問題に必要なIsingグラフ(ゼロではない重みを持つ辺と頂点の集合であり, 主グラフとも呼ばれる)は, グラフG自体である. 
グラフG_{1}=(V,E)の最大クリーク問題を解くときは, まずグラフをG_{2}=(V,\overling{E})に補完し, G_{2}上のMISを解く必要がある. したがって, |V|個の変数と|\overline{E}|個の二次項が必要になる. 
したがって, 非常に密なグラフで最大クリーク問題を解くこのが簡単になり, それによってスバース補完グラフが生成される. 

3.3 Methods
D-Wave2Xシステムはキメラグラフと呼ばれる, 特定のグラフトロポジによって成っている. 
これは12×12セルの格子で, 各セルは4×4の二部グラフである. 
D-Wave 2Xはゼロでなない二次項がキメラグラフの辺で表される問題を自然に解決できる. 
他の問題については, 埋め込みが必要である. すなわちシミュレートされた変数の接続性を高めるために, 論理変数は一連の物理量子ビットで表さなければならない. 
D-Wave 2Xが理論上埋め込める最大の完全グラフは, 1+4*12=49の頂点を持つ. 
製造時のデフォルトから量子ビットの欠落のため, わずかに小さくなる(n=45).

今回の研究で必要な接続の最大数は完全グラフまでになるかもしれない. 
したがって, D-Wave 2Xで確実に解ける最大のグラフは45頂点のグラフである. 
大きなグラフでは, 辺の密度とトポロジによって異なる. 

したがって, 任意のグラフでMIS問題を解くためには, 最初の入力グラフを最大でも45頂点の小さいグラフに分割する分割統治法を行う必要がある. 

3.3.1 Sapi parameters
SapiはソルバAPIを表す. これは, 量子アニーラを制御できる最低レベルの制御である. 
ここで, sapi Cクライアントのバージョン2.4.2を使用する. 
最初にQUBO問題をIsing問題に変換する. 
3.4.2節の実験では, 全45頂点のグラフの事前計算された埋め込みを使用する. 
2.3.2節では埋め込みについて計算する必要はない. 
チェーンなしで元の問題に後処理が適用されるようにするために, ソルバのチェーンパラメータへの埋め込みをする.(このパラメータでは, 後処理を適用する前に, ソルバは最初に多数決投票を適用してチェーンを解決する.)
チェーンを扱うのにこの方法は最良の方法であることは今回の実験で示された. 

3.4 Results
3.4.1 Software solvers
D-Wave 2Xでの結果は様々なソルバでのものと比較した. 
Ising問題に対して動作するシミュレーテドアニーリングアルゴリズム(SA-ising), クリーク問題を解くために特別に設計されたシミュレーテッドアニーリングアルゴリズム(SA-clique), ヒューリスティックまたは厳密モードでクリークを見つけるために設計されたソフトウェア(fmc)とGurobiソルバ. 
D-Waveの後処理ヒューリスティックのみから得られた結果も比較に含める. 

SA-ising : 
これはising問題に対して作用するシミュレーテッドアニーリングアルゴリズムである. 
初期解はランダム解であり, シミュレーテッドアルゴリズム内の単一の動きは1ビットのランダム反転である. 

SA-clique : 
X.Genらによって記述されたクリークを見つけるために設計されたシミュレーテッドアルゴリズムを実装した. 
このアルゴリズムは特定のサイズmのクリークを見つけるように設計されているので, 最大クリークサイズを見つけるためにバイナリ検索に適用する必要がある. 
メインパラメータは各ステップで温度を更新を操作するαである. T_{n+1} = αT_{n}. 通常はα=0.9996を使用する. 
1に近い値だとより解に近づくが, 計算時間が増加する. 

Fast Max-Clique Finder(fmc) : 
これは大きなスパースグラフに対して最大クリークを効率的に見つけるために設計されたアルゴリズムである. 
これは正確であり, 発見的な探索モードを提供する. 
今回の実験ではバージョン1.1のfmcソフトウェアを利用した. 

Post-processing heuristics alone(PPHa)
D-Waveのパイプラインには後処理ステップが含まれる. 
最初に, チェーンが存在する場合には多数決が適用されて破損したチェーンが修正される. 
解が局所最小値にするために, そこから局所探索が実行される. (d-Waveから発生する解は局所的には最小ではないかもしれない.)
パイプラインから出てくる特定の解について, D-Wave 2Xシステムと後処理ステップの相対的な貢献は何なのかと思うかもしれない. 
小さくて単純な問題に対しては, 後処理のステップだけで良い解を見つけられるかもしれない. 

後処理ステップのみを適用することで解を得ようとし, 実際の量子アニーリングと比較してみてください. 
しかし, この後処理ステップはD-Waveサーバ上で実行し, これは別に利用できる. 

そのために, 特別な手順が必要になる. 
非常に高い絶対チェーン強度を設定し(例:問題の最大重量の1000倍), "自動スケール"機能をオンにする. 
その結果, チェーンの重みは最小値-1に設定され, 他の全ての重みは0に縮小される. 
このようにして, 量子アニーラはチェーンを満たすようにするだけで, それ以外は解かない. 
各チェーンは何にも接続されておらず, 全ての線傾項はゼロになるので, 各チェーンはランダムな値-1または+1を持つ. 
したがって, 後処理ステップにはランダムな初期解が与えられ, パイプラインの終わりに得られるものは後処理ステップのみの結果になる. 
これは後で, PPHaと呼ばれる. 

3.4.2 Results
小さいグラフの結果 : 最初に, 最大45頂点を持つグラフに対する量子アニーラの振る舞いを調べた. 私は, 埋め込むことができる最大のグラフを分析する. 

私たちは500頂点で密度が増加するランダムグラフに対してグラフ分割法法のテストをする. 
生成されるグラフの密度は0,1から0.4の範囲の辺の存在確率によって制御される. 
図1はこの実験の結果を示している. 
ここでは, 辺のぞんざい確率に関して入力グラフ(今回は生成されたサブグラフの数)を解くために必要なソルバコールの数を報告する. 
各データ点は, 10回の実行結果の中央値であり, 標準偏差はエラーソルバとして示されている.
ソルバの呼び出し数は, 入力グラフの密度に関する指数関数曲線に従う. 

二番目の実験では, 任意の大きさのグラフに対するクリーク発見アプローチに対する将来世代のD-Waveシステムの影響を測定する. 
将来世代のD-Waveシステムにも同様のキメラトポロジーがあると仮定すると, 利用可能なQピットの数を二倍にすると, 最大√2倍のサブグラフのサイズが増加する.
図2ではQビットの増加数に対するソルバコール数の展開を示している. 
この実験では, グラフサイズは500頂点で固定し, 辺の存在確率は0.3に固定されている. 
各データ点は10解の実行の中央値であり, 標準偏差はエラーバーとして示されている. 
Qビットの数が新世代ごとに倍になっていることを考えると, 7世代目のD-Waveマシンが任意の500頂点のグラフを直接埋め込んで解くのに必要になる. 

表1
45頂点のランダムグラフの実行時間.
グラフは, 最初の列の数値に等しい辺の存在確率で生成される. 
これらの小さいグラフでは, 全てのソフトフェアが正しい解を返すので実行時間のみが報告させる.

図1
ソルバの呼び出し数は, グラフ密度の増加に伴い指数関数的な傾向に従う.

3.4.3 Artificial graph designed to fit chimera
ここでの考えは, D-Wave 2Xが可能な限り最高のシナリオで達成できるスビートを確認することである. 
この可能な限り最良のシナリオは, キメラグラフ, すなわち非常に少数の連鎖を必要とするグラフであり, うまくいけばMIS問題が自明でないグラフである.

グラフ生成
1100個の量子ビット(これは, 量子ビットがないためにシステムごとに異なる可能性がある.)の場合における, D-Wave 2XシステムのG=(V,E)の実際のキメラグラフから始める. 
これは, システムが解くことができる最も密な1100頂点のグラフである.
このグラフは二部構成であるのでMIS問題には関係がないことに注意する. 二部グラフ上のMISは自明な問題であると考える人もある.

グラフCから一つのランダムな辺を縮小することによって得られるグラフC_{1}を考える.
辺の縮小は, 辺v1,v2の削除および頂点v1とv2の融合である.
N1とN2がv1とv2からの隣接頂点の集合で, 融合ノードの隣接ノードはN1UN2\{v1,v2}.
C_{1}は|V|-1個の頂点を持ち, キメラグラフのマイナーと呼ばれる.
定義により, このグラフのMIS問題の定式化は次のように埋め込むことができる.
埋め込みは辺の縮小によって与えられる.
さらに, C_{1}に辺を追加した場合, C_{1}はすでにキメラグラフの全ての可能な量子ビットと辺を使用しているため, 結果のグラフはキメラに埋め込むことはできない.
したがって, グラフC_{1}はキメラが埋め込むことができるサイズ|V|-1の最も密なグラフの一つであると言える.

m個のランダムな辺収縮後に一般化することができる.
結果として得られるグラフC_{m}は|V|-m個の頂点を持ち, サイズ|V|-mのキメラが埋め込むことができる最も密なグラフの一つとなり, 二部グラフにはならない.
したがって, 0<m<1100のこのグラフの群C_{m}は, MIS問題に対する最良のシナリオの実験である.すなわちキメラに埋め込むことができ, そしてその解き方が自明ではない大規模なグラフ実験のための良い候補である.

実験
D-Wave 2XのSapi, PPHa, およびSA-Isingソフトウェアを使用して, C_{m}群のグラフのMIS問題を解く.
SA-cliqueとfmcを使用して, 補数グラフの等価な最大クリーク問題を解く.
図3は結果を示している.
グラフサイズ400までは, PPHaはD-Waveと同じ結果になる.
これらの小さなグラフでは, 問題はおそらく後処理ステップだけで解けるほど簡単である. 
想定通り, クリークように特別に設計されたシミュレーテッドアニーリングはSAイジングよりも良好に動作している.
fmcソフトフェアはヒューリスティックモードで実行されている.
これは大規模な疎グラフ用に設計されており, ここでは非常に密集したグラフ上で実行されている.これがおそらく比較的低品質の低い結果の理由である.

大きなグラフ(頂点が800を超える)の場合は, D-Wave 2Xが最良の解を提供する.
それが最適な解であるかどうかはわからない.

スピードを上げる.
SAクリークはD-Wave 2Xと比較するのに最適な候補であると思われるので, このC_{m}群のグラフでSAクリークと比較してD-Wave 2Xの速度を計算することにした. 
手順は以下のようになる.
各グラフサイズごとに, 500回のアニールでD-Wave 2Xを実行し, 最良の解を報告する.
D-Wave 2Xランタイムは500アニール, つまり約0.15秒の合計qpuランタイムである.
SAクリークについては, 低いαパラメータ(すなわち急速冷却スケジュール)から初めて, SAクリークがD-Wave2Xと同じ解を見つけるまで徐々にαを増加させる.
SAクリークが同じ解を見つけたこのαは, SAクリークに最良の実行結果を与える.
SAクリークアルゴリズムは次のようなCPUで動かしている.
図4は異なるグラフサイズ(C_{m}群)に対するスピードアップを示している.
頂点数が200以下の小さなグラフに対してはD-Wave2Xは遅いが, 大きなグラフに対しては, 指数関数的に速くなり, 最大で百万のスピードアップになる.

これはD-Wave2Xの最良のシナリオであり, ランダムグラフで得られるものを代表するものではないが, これはD-Wave2Xシステムにおける量子的振る舞いを示す証拠になる可能性がある.
D-Wave2Xは, 我々が試した全ての古典的なソルバでは得ることが非常に難しい解を非常に速く見つけることができる.

4. Graph partitioning
この章では, グラフ分割のための様々な方法を調べる. 
焦点は, グラフ分割問題には二つのバリエーションがあることである.
エッジカット分割とコアハロ分割
この目的のために, 4.3節では, 両方のタイプの分割を実行するために, IsingまたはQUBOのどちらかの形式でハミルトニアンを提供する.
次に, シミュレーション研究(4.2節)でそれらの性能を評価するために, 2節で概説した方法を使用してからのハミルトニアンを様々なグラフ上で最小化する.

4.1 Hamiltonian formulations
4.1.1 Ising model for graph partitioning
論文[20]では標準的なエッジカット分割を実行するためのイジングハミルトニアンを与える.
しかし, この定式化は, グラフを二つの要素に分割するとに適している.
n個の要素への一般化は次の節で導き出される.

エッジカット分割は, エッジカット, すなわち異なるパーティションに属する頂点を結ぶ辺の数が最小になるようにグラフをパーティションに分割することを目的としている.







