Physics-Inspired Optimization for Quadratic Unconstrained Problems Using a Digital Annealer

富士通のデジタルアニーラはフルコネクトのQUBO問題を解くために設計された. CMOSハードウェアに実装され, 現在1024変数までの問題を解く. デジタルアニーラのアルゴリズムはシミュレーテッドアニーリング元にしている. しかし, 効率的な並列試行方式と動的エスケープメカニズムの利用している点で異なる. 加えて, デジタルアニーラは特定用途向けのCMOSハードウェアが可能にする大規模な並列化を利用する. デジタルアニーラとシミュレーテッドアニーリングの振る舞いを比較し, 等エネルギークラスタによる平行焼き戻しは二峰性およびガウス性結合をもつ二次元および完全結合スピングラス問題状に移動する.
これらは, スパース対密問題, および高縮退対低縮退問題のそれぞれの限界を表している.
我々の結果は使用されているシミュレーテッドアニーリングおよび並列焼き戻しのシングルコアの実装に対してデジタルアニーラが, 現在バイモーダルまたはガウスカップリングによる完全結合スピングラス問題に対して, 約二桁の時間短縮を実現することを示している
デジタルアニーラは, 疎な二次元スピングラス問題のスピードアップを示していないようで, 理論的な理由で説明している. 
また, パラレルテンパリングデジタルアニーラの早期実装のペンチマークも実施した.
我々の結果は, 二峰性障害を伴う平均困難性の完全に関連した問題に対して他のアルゴリズムよりも改善されたスケーリングを示唆している.
次世代のデジタルアニーラは, 最大で8192変数のサイズで, 完全に接続された問題を解決すると期待されている.
これにより, これまで標準的な計算ハードウェアや特殊な目的の量子アニーリング実装を使用してもアクセスできない基本的な物理学の問題や産業用途の研究が可能になる.

1 Introduction
離散最適化問題は様々な分野で広く適用されており, 特に多くのNP困難な組み合わせ最適化問題は, 二次イジングモデルまたはQUBO問題にマッピングできる. 
このような問題は金融, 化学, 生物学, ロジスティクスとスケジューリングおよび機械学習を含む多くの研究分野で自然に発生する. 
これらの問題を効率的に解決することに大きな関心が寄せれれている.

ムーアの法則の差し迫った終わりは, 伝統的なシリコンベースのコンピュータデバイスに頼ることは現在の計算性能の成長率を維持することは期待させていないことを示している.
この観点から, 新規な計算技術に対する関心は着実に高まっている
D-Wave System Inc.による特殊目的の量子アニーラの導入は, 量子の揺らぎを使用して計算集約型離散最適化問題を解決する方法に革命を起こすことを目的としたものである.

従来の市販のCMOSハードウェア上のアルゴリズムに対する量子アニーラのスケーリング上の利点を探求する努力が続けられているにもかかわらず, まだ合意は得られていない.
シミュレーテッドアニーリング(SA)のような古典的な対応物に対するベンチマークの量子アニーラへの努力は[14,15-30]
いくつかのクラスの合成問題では最初は大きなスピードアップが見られましたが, それらの問題は後に自明な理論構造を持つようになり, より強力な古典的アルゴリズムによってより効率的に解決できるようになった.
私たちの知る限りでは, スピードアップの唯一知られているケースは合成問題のクラスに対する一定のスピードアップであり, これまでのところ, 産業上の応用に対するスピードアップの証拠ではない. 
量子アニーラ, 特にアナログノイズによる現在の疎な接続性と低精度に対する将来の改善が最適化問題の解決における量子効果の力を実証することが期待されている.
同じ目標を念頭に置いて, 研究者たちはコヒーレントイジングマシンなどの新しいハードウェア, およびグラフィックプロセッシングユニット(GPU)や特定用途向けのCMOSハードウェアでこのような問題を解決しようとしている.
同様に, 市販されているCMOSハードウェア上で実行される古典的なアルゴリズム(しばしは量子または物理にヒントを得た方法と呼ばれる)で量子効果をエミュレートしようとする努力は最適化領域におけるかなりの進歩をもたらした(例えは, 異なるアルゴリズムの概要にするいては参考文献[30]を参照)

富士通ラボラトリーズは最近, デジタルアニーラ(DA)として知られる, 完全に接続されたQUBO問題を(すなわち, 完全グラフ上で)解決するように設計された特定用途向けCMOSハードウェアを開発した.
DAハードウェアは現在1024変数までのイジング最適化問題を取り扱うことができ, バイアスと可変カプラに対して, それぞれ26ビットと16ビットの固定精度を持つ.
DAのアルゴリズムはSAを参考にしているが,  いくつかの点で異なり, カスタムのアプリケーション固有のCOMSハードウェアを使用した場合に可能な最大規模な並列の利用できるという点で異なる.
SAを並列して実行する以前の努力は, AP1000超並列分散メモリマルチプロセッサ上で異なる反復を並列して実行していた.
DAに加えて, PTDAと呼ぶアルゴリズムエンジンに並列焼き戻しモンテカルロを使用するDAのバージョンが利用可能である.
特に, SAや並列焼き戻しモンテカルロなどの物理学にヒントを得た最適化技術はm 通常D-Waveデバイスなどの特殊化された量子ハードウェアを凌駕している.
ベンチマークの取り組みの多くは, 一つのハードテーブル最適化問題の中で最も単純なものであるため, 一種の制約充足問題であるスピングラスに集中している. 
さらに, 例えば業界のアプリケーションベースのベンチマークは構造化される傾向があるため, 体系的なベンチマークは困難である.
そのため, スピングラスは既成のCPU, 量子アニーラなどの新しいコンピューティングテクノロジ, およびコヒーレントイジングマシンのベンチマークに広く使用されている.
本稿では, スピングラス問題についてDAとPTDAをベンチマークし, 等エネルギークラスター移動(スピンの熱シミュレーションではなく, Houdayerスラスタ更新の変形)を用いたSAおよび並列焼き戻しモンテカルロと比較する. これらは最先端の物理学にヒントを得た最適化アルゴリズムである.
QUBO問題を解決するために文献で使用されている他の代替的な古典的最適化手法については, 興味のある読者が論文[22,30,51]を参照している.

この論文では以下のように構成されている. 
セクション2では, ベンチマークしたアルゴリズムについて説明. 
セクション3では, シングルトライアルモンテカルロ移動に対するパラレルトライアルの利点を検証し, セクション4では, 解決までの時間を計測するために使用した方法論について説明する. 
セクション5では, ベンチマークされた問題を紹介する. 
実験結果はセクション6で提示し議論する. 
最後に, セクション7で我々の結果を示す. 
ベンチマークに使用したパラメータはAで示している. 

2 Algorithms
この項ではいくつかのMCアルゴリズムと最適化問題を解くための利用について. 

A. シミュレーテッドアニーリング

B デジタルアニーラのアルゴリズム
DAのアルゴリズムエンジンはSAに基づいているが, 主な三つの点で異なる. 
まず, ランダムな状態から各実行を開始するのではなく, 同じ任意の状態から全ての実行を開始する. 
その結果, 初期のN個の有限磁場と各runの初期エネルギの計算が回避されるため, わずかなスピードアップにつながる. 
次に, 各モンテカルロステップが全ての変数の反転を(別々に)並列して考慮する並列試行方式を使用している. 
少なくとも一つのフリップが受理されると, 受理されたフリップの一つがランダムに一様に選択されて適用される. 
SAでは, 各モンテカルロステップは単一変数の反転のみを考慮していることを思い出してください(すなわち, 単一試行).
並列試行方式の利点は, Nフリップのフリップアウトを受け入れる可能性が通常特定の変数をフリップする可能性よりもはるかに高いため, 許容確率を高めることができることである(セクション3を参照).
GPU上の並列棄却アルゴリズムは, モンテカルロ法における低許容確率問題に取り組むための文献における同様の取り組みの例である. 
最後にDAは動的オフセットと呼ばれるエスケープメカニズムを採用しており, フリップが受け入れられなかった場合, 提案された移動に関連するエネルギーの差から正の値を引くことによって後続の受け入れ確実が人工的に高められる. 
これは, アルゴリズムが短く狭い障壁を乗り越えるのに役立つ. 

さらに, アプリケーション固有のCMOSハードウェアにより, 最適化問題をより迅速に解決するために活用できる大規模な並列化が可能になる. 
例えば, DAでは, 全ての変数の反転を評価することが並列して実行され, 反転が受け入れられ適用されると, 全ての近傍の有効フィールドが並列して更新される.
このステップは, ハードウェア上の並列化のために近隣の数に関係なく一定の時間を必要とするのに対して, SAにおける同じステップの計算時間は近隣の数において線形に増加することに留意されたい.

DAの背後にあるロジックを理解するためには, DAハードウェアに特有のいくつかのアーキテクチャ上の考慮事項を理解することが役立つ. 
DAでは, フリップが受け入れられたか(したがって, 適用されたか)かどうかに関わらず, 各モンテカルロステップに同じ時間がかかる. 
これと対照的にSAのCPU実装では, 受け入れられた移動は通常, 拒否された移動よりはるかに計算コストが高くなる. これは, フリップが拒否された場合, Nフィールドを更新する必要がないためである.
その結果, DAでは(パラレルトライアル方式を使用することによる)受け入れ確率の潜在的な向上が強く望まれる.
さらに, DAでは有効フィールドを更新する計算上の複雑さは, グラフの接続性に関係なく一定である.
これをSAと比較すると, 有効フィールドを更新する計算上の複雑さは完全グラフではO(N)であるが, 固定字数グラフではO(d)である(各ノードにd個の隣接ノードがある).
したがって, 疎なグラフではSAを実行すると通常密なグラフよりも高速になるがDAの場合でも同様である.
そのため, SAに対するDAの高速化は一般に疎なグラフよりも密なグラフの方が高いと予想される.

最後に, ハードウェアに実装された擬似乱数発生アルゴリズムは, ねじれ一般化フィードパックシフトレジスタアルゴリズムと同様であり, 2^{19937}という十分に長い期間を与えることに言及する価値がある.

C. Parallel Tempering with Isoenergetic Cluster Moves 等エネルギクラスタ移動による並列焼き戻し

パラレルテンパリング(PT)(レプリカ交換モンテカルロとも呼ばれる)では, システムの複雑のレプリカが異なる温度間のメトロポリス基準に基づいて定期的に交換される.
したがって, 各レプリカは温度空間内をランダムに移動し, 一時的に高温に移動することでエネルギー障壁を克服することができる. 
温度のレプリカは通常, システムに新しいランダム状態を注入するのに十分な高温で, 本質的にアルゴリズムを連続的に再シードし, 複数の実行を実行する必要性を(少なくとも部分的に)回避する.
PTは複数の研究分野で効果的に使用されており, 混合が増加しているため, SAよりもパフォーマンスが高いことがよくある.

等エネルギークラスター移動(ICM)をPTに追加すると, 一度に複数の変数を反転させることができるが, これは変数クラスターがシステム全体に及ばない場合に限られる.
ICMはHoudayerのクラスターアルゴリズムを一般化したもので, 二次元スピングラス問題に合わせて作られた.
ICMを実行するために, システムの二つ(またはそれ以上)のコピーが同じ温度でシミュレートされる. 
次に, それら二つのレプリカの状態を比較して, 反対の変数のクラスタ(すなわち連結成分)を見つける.
QUBO問題の場合, 反対の変数は積がゼロであると定義される.
最後に二つのレプリカの反対側の変数の状態を交換することによって, 移動が適用される. 
二つのレプリカの合計エネルギーは, この移動によって変化しない. つまり, 二つのレプリカのエネルギーは棄却されない. 
PTとICMの組み合わせであるPT+ICM(ボレアスとしても知られている. アルゴリム3を参照)は, 低次元のスピングラスのような問題に非常に効果的であることが示されている. しかし連結グラフで定義された問題に対しては利点がない. 
これは, クラスタがシステムにまたがる時, ICMが本質的に状態を完全に交換することになることに注意することが理解できる. 

D. The Parallel Tempering Digital Annealer's Algorithm

DAのアルゴリズムはSAに基づいており, PTがSAよりも優れた結果をもたらすことが多いため(たとえば, 参考文献[30]を参照), Fufitsu Laboratories は Parallel Tempering Digital Annealer(PTDA)も開発した. 
私たちはPTDAの早期実施へのアクセスを持っていた. 
PTDAでは, パラレルトライアル方式, パラレルアップデート, 動的オフセットメカニズムの使用など, 各レプリカのスイープはDAと同様に実行されるが, PT移動はCPU上で実行される. 
温度は, Hukushimaらによる適用方式に基づいて自動的に設定される. 
この方式では, 高温と低温は固定されており, 全ての隣接温度に対して等しいレプリカ交換確率を達成する目的で中間温度が調節される. 
この方式も存在するが, レプリカ交換の受け入れ確率が等しいことが一般的な目標である. 

次世代のDigital Annealerは8192変数までのサイズの完全グラフ上で問題をシミュレートし, アニーリング時間を短縮し, CPU上ではなくハードウェア上でレプリカ交換移動を実行できるようになると期待されている. 
これは重要であり, 並列で計算を実行する場合, 作業の一部が順次実行されると, (並列スレッドの数が増えるにつれて)全体の実行時間を左右するボトルネックが発生するためである. 
Amdahlの法則は, シーケンシャル部分が総作業量の分数αである場合, スピードアップは漸近的に1/αに制限されると述べてこれを定量化する. 

3. Parallel-trial Versus Single-trial Monte Carlo
シングルトライアルモンテカルロ更新に対するDAで実装されたパラレルトライアルモンテカルロ更新の利点を説明するために, それぞれの許容確率を計算する. 

特定のモンテカルロ移動の許容確率は, メトロポリスの基準A(ΔE,T)によって与えられる. 
ここで, ΔEは, 反転変数iに関連するエネルギーの差を表し, Tは温度である. 
単一試行受理確率は式(1)で与えれらる. ここでNは変数の数である. 
式(1)
対照的に, パラレルトライアルの受け入れ確率は, 移動を受理しないという補完的な確率によって与えれらる. 
式(2)
低温では, 一般に許容確率がゼロに達すると予想される. 
A→0の極限では, 並列試行受理確率の一次近似は式(3)で与える. 
式(3)
これは, 最善の場合, 低温ではN倍のスピードアップがあることを示している. 
対照的に, 十分に高い温度では, 全ての動きが受け入れられ, したがってA→0である. 
この限界では, 単一試行と並列試行の両方の受理確率が１に達することは明らかであるため, 並列試行モンテカルロは単一試行モンテカルロを超える利点はない. 
パラレルトライアルとシングルトライアルのモンテカルロの違いを定量化するために, 十分な数の掃引が熱化に達するように一定温度でモンテカルロシミュレーションを実行する. 
システムの温度が上昇したら, 一回の試行ごとに単一試行および並列試行の許容確率を測定する. 

そのような実験の結果は, ５章に詳細に記載されている4つの問題クラスのサイズN=64の問題について, 図1に提示されている. 
問題クラスは, 二峰性およびガウス性の無膣錠性をもつ二次元(2D）および完全連結[シュリントンカープパトリク(SK)]スピングラス問題が含まれる. 
2D-二峰性クラスを除く全ての問題クラスの結果は, 低温でゼロに達し, 高温で1に達する許容確率の予想パターンに従う. 
二次元二峰性の場合には, 基底状態においてさえ, フリップがエネルギーの変化をもたらさない単一の変数があるように, 巨大な基底状態縮退がある. 
これは非常に低い温度でさえも肯定的な単一試行受理確率をもたらす. 
同じ理由で, 並列試行確率は非常に低い温度でも1に達する. 

シングルトライアルの更新に対するパラレルトライアルの許容確率の優位性を定量化するには, 図2に示すように, パラレルトライアルの許容確率をシングルトライアルの許容確率で割った値を検討することが有益である. 
式(3)を式(1)で割ることによって示唆されるように, 低音での利点は確かにNのファクタである. 
上記で説明したように, 2D-二峰性の場合には, 単一試行の受理確率は低温では無視できないため, 利点が減少する. 
並列試行方式の利点は, 熱化時間が長い低温で最高になることは注目に値する. 
このように, パラレルトライアルスキームは, それが最も必要とされる場所で許容確率の向上をもたらす. 

4. Scaling Analysis
ベンチマークの主な目的は, 問題のサイズ(例えば, 変数の数)が増加するにつれて, 問題を解く際に計算量がどの程度拡大するかを定量化することである. 
ここで考えるアルゴリズムはすべて確率論的なもので, 確率的アルゴリズムのスケーリングを測定するための一般的なアプローチは0.999の確率で少なくとも一回, 参照エネルギー(コスト)を見つけるために必要な合計時間を測定することである. 
基準エネルギーは, 利用可能であれば最適エネルギーによって, あるいはそうでなければ, 最もよく知られているエネルギーによって表される. 
この時間を"TTS"で解くことにし, これがこのセクションの残りでどのように計算されるかを説明する. 

確率的アルゴリズムの連続的な実行は, ある確率で基準エネルギーを返すことに成功するかもしれない二項実験のシーケンスであると考える. 
ここで, P(Xi=1)=θが成功する確率, すなわちi番目の実行での参照エネルギーを観測する確率を表す, Xi,..,Xrをr回の実行(実験)のランダムな独立した結果のシーケンスとして正式に定義する. 
式(4)をr回の実行で成功した観測の数として定義すると, 式(5)が得られる. 
式(4)
式(5)
つまり, Yはパラメータrとθをもつ二項分布になる. 
我々は, 0.99の確率で基準エネルギーを見つけるために必要とされる実行の数をR_99として表し, それはP(Y≧1|θ,r)=0.99となるようなrに等しい.
式(6), ひいては式(7)であることを確認できる. 
式(6)
式(7)
ここで, τはアルゴリズムを一回実行することにかかる時間である. 
成功確率θは未知であるので, 課題はθを推定することにある. 

サンプル成功率をθの点推定値として使用する代わりに, ベイズ推定法に従って各問題インスタンスの成功確率の分布を推定する. 
成功確率の分布を持つことは, TTSの様々な統計の分散をより正確に把握するのに役立つ. 
ベイジアン推定フレームワークでは, 事前分布として知られているθの分布についての推定から始め, 事前分布を得るためにアルゴリズムの連続実行からの観測に基づいてそれを更新する. 
連続した実行は二項分布をしているので, 事前の適切な選択はベータ分布で, これは二項分布の前の共役である. 
この選択は事後分布もベータ分布を持つことを保証する. 
パラメータα=0.5およびβ=0.5(ジェフリーズ事前分布)を有するベータ分布は, 空間の再パラメータ化のものでは不変であり, データから最も多く学習するので事前分布として選択される. 
連続した実行からの観測に基づいてJeffreys事前を更新すると, π(θ)で表される事後分布はπ(θ)からβ(α+y,β+r-y)であり, ここでrは実行の総数である. そして, yは, 基準エネルギーが検出された実行数である. 

似たパラメータを持つインスタンスの母集団全体のTTSを推定するために, 同じ数の変数を持つインスタンスがあると仮定する. 
集合{1,2,...,I}, 我々はTTSのq番目の百分位数の分布を推定するためにブーストラッピングを使用する. 
この手順はアルゴリズム4で説明している. 











