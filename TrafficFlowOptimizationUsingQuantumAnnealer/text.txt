Traffic Flow Optimization Using a Quantum Annealer

量子アニーリングアルゴリズムは, メタ最適化ツールのクラスに属し, バイナリ最適化問題の解決に適用できる.
D-Wave Systemsが製造する量子処理ユニット(QPU)などの量子アニーリングのハードウェア実装は, 最適化およびサンプリングタスクに対する技術の有用性を特徴付ける目的で, 研究の分析の対象となった.
この論文では, 量子テクノロジーを使用した実世界のアプリケーションを紹介する.
具体的には, 実世界の交通流の最適化問題の特定の部分を量子アニーリングに適するようにマッピングする方法を示す.
密集した道路ネットワーク内の自動車の位置データの継続的な再配布など, タイムクリティカルな最適化タスクが量子コンピューティングに適していることを示している.
現在の世代のD-Wave QPUのサイズと接続性は限れれているため, トラフィックフローの問題を解くために, ハイブリッド量子および古典的アプローチを使用している.

1. Introduction 
D-Wave Systems製の量子処理装置(QPU)などの量子アニーリング技術は, 複雑な組み合わせ最適化問題をとくように設計されている.
以前の実験では, これらのQPUが量子アニーリングを実装する方法と, アニーリングプロセス中にQPU内の量子ビットがコヒーレントで絡み合ったままであることを示した.
また, サンプリングと最適化の両方のタスクにおいて, 量子ビットの量子特性が会の計算でどのような役割を果たすかが示されている.
QPUは, 各量子ビットが変数を表し, 量子ビット間のカプラが量子ビットペアに関連するコストを表す, 二次非制約バイナリ最適化(QUBO)問題を解くように設計されている.
QPUは, 頂点として量子ビットと, それらの間の辺としてカプラを持つ無向グラフの物理的な実装である.
QPUが最小化するように設計さているQUBOの機能形式は次のとおりである.
(式1) Obj(x,Q)=x^T・Q・x
ここで, xはサイズNのバイナリ変数のベクトル, Qは変数間の関係を記述するN×Nの実数値行列である.
行列Qが与えられると, 式(1)の目的関数を最小化するためのバイナリ変数割り当てを見つけることは, 既知のNP困難問題であるイジングモデルを最小化することと同等である.

この論文では, トラフィックフローの最適化問題を紹介する.
車のGPS座標のT-Drive軌跡データセットから始め, リアルタイムで交通流を最適化することを目的とするシステムを模倣するワークフローを開発する.
D-Waveシステム(それらを使用するマシンツールととフトウェアツールの両方を含む)で最適化するために, 問題の主要な要素をQUBO形式に変換する方法を示す.
D-Waveシステムをオプティマイザーとして扱い, 実際のアプリケーションに似たワークフローにD-Wave QPU呼び出しを統合できることを示している.
ここで紹介する方法は, この実世界の問題を量子コンピュータにマッピングするための新しいアプローチである.

2. Formulation of the Traffic Flow Problem
交通流最適化問題の目的は, 特定の車がここの出発地と目的地の間を移動する時間を最小限にすることである.
道路を横断する時間は, 現在道路を占有している車の数の関数に比例するという単純な仮定を使用した.
したがって, 全ての道路セグメントの混雑を再商店に抑えることで, 全ての車の合計時間を再商店に抑える.
個々のセグメントの輻輳は, 特定の時間感覚でセグメントを通過する車の数の二次関数によって決定される.
再現性を確保するために, 一週間に記録された10,357台のタクシーの軌道を含む公的に利用可能なT-Drive軌道データセットを使用した.
データセットは, 1500万のデータポイントを特徴とし, 軌跡の合計距離は, 900万キロメートルを占める.
全ての車に1〜5秒の間隔でGPS座標を送信する必要があった.
データセット内の全ての車がこの速度で転送データを提供するわけではないため, GPSポイント間を補間することでデータセットを強化した.
以下に概説するステップバイステップのワークフローに問題を分割した.
「古典的」とは古典的な機械での計算を指し, 「量子」とはD-Waveシステムでの計算を指す.

1. 古典：マップおよびGPSデータの前処理
2. 古典：交通渋滞が発生しているエリアを特定する
3. 古典：可能であれば, データセット内の各自動車の空間的および時間的に有効な代替ルートを決定する
4. 古典：最小化問題をQUBOとして定式化する(重複するルート乗の道路セグメントの混雑を最小限に抑えるため)
5. バイブリッド量子/古典：トラフィックグラフ全体のルート割り当て間の輻輳を軽減する解を見つける
6. 古典：結果に基づいて車を再配布する
7. 渋滞が特定されたくなるまで手順2〜6を繰り返す

入力グラフの可視化を図1に示す.
この視覚化は, OpenStreetMapに基づくOSMnx APIを使用して生成され, OpenStreetMapからストリートネットワークを取得, 構築, 分析, 視覚化することができる.

2.1 Determination of Alternate Routes
問題の定式化を説明するために, T-Driveデータセットのサブセットに焦点を当てる.
データセット内の10,357台の車のうち, 市内中心部と北京空港を往復する車を418台選択する.
この特定のシナリオでは, 目標は交差する道路セグメントの数が最小になるように, 418台の車のサブセットを代替ルートにリダイレクトすることにより, 交通量を最大化することにした.
このためには, 全ての車を同時に最適化する必要がある. つまり, 元の混雑を解決する車の再配分は, マップ内の他の場所で混雑を引き起こしてはならない.
OSMnxパッケージを使用して, 北京のマップをセグメントとノードに分割し, それぞれ一意にIDを割り当てた.
手順は, 次のように要約できる.

1. OSMnxを使用して, 北京市内の地図から道路グラフを抽出する.
   これは, IDを持つセグメントとノードのリストを返す.
   ノードはセグメント間の接続を表し, セグメントはノードを接続する辺であり, 道路を表す(図1)
   
2. T-Drive軌跡データセットの車のGPS座標をグラフ内の道路セグメントにマッピングして, 車がとるルートを決定する.

3. 各自動車, および各出発地と目的地のノードについて, 出発地から目的地までの全ての単純なパスを抽出し, ３つの代替ルート候補を取得する.
   これから３つの候補を提案された代替ルートとして使用して, トラフィックを再配布する.

2.2 Formulating the Traffic Flow Optimization in QUBO Form
QUBOの変数の定義(式(1))では, 入力に対して古典的な前処理が必要である.
稀に, 車を別のルートに切り替えることができない場合がある.
例えば, 車の近くに交差点またはランプがない場合, 再ルーティングの対象とはみなされず, 元のパスに残る.
それにもかかわらず, この車は他の車のルーティングに影響を与えるが, QUBOに含まれる.
図2は, ワークフローで使用されている道路セグメントが車に割り当てられている例を示している.

交通量を最適化するために, 各車両に割り当てられたルート間で重複するセグメントの数を最小限に抑える.
したがって, 次のように最適問題を定式化する.
「車ごとに３つの可能なルートがある場合, どの車をルートに割り当てると, 全ての道路セグメントの混雑が最小限に抑えられるか？」
全ての割り当てられたルートの混雑を最小限に抑えながら, 全ての車に３つの可能なルートのいずれかを割り当てる必要がある.
この例では, 各車が３つの可能な代替ルートを提案することを強調することが重要であり, 全ての車の３つのルートの同じセットではない.
これは一般にそうである必要はないが, 車には多くの可能なルートがある.
簡単にするために, 問題の数学的記述はルートの数に関係なる同一であるため, 一台の車につき(最大)3ルートを使用する.

車のルートへの可能な割り当てごとに, ルートjをとる車iを表すバイナリ変数q_ijを定義する.
各車両は一度に１つのルートしか占有できないため, QUBOの最小値では, 車両ごとに１つの変数が真でなければならない.
全ての車が正確に１つのルートを取る必要がるように, 制約を定義する.
これは, 次の制約として定式化できる(３つの可能なルートを想定):
(式2)
バイナリルールx^2=xを使用して簡略化.
前述のように, ルートは道路セグメントのリストで記述される.(Sはグラフ内の全ての道路セグメントのセットである)
したがって, 全ての道路セグメントs\in Sについて, 道路セグメントsを共有するルート(このセットBを呼び出す)に関連付けれた全てのバイナリ変数q_ijを識別し, 占有コスト関数を定式化する.
(式3)
例えば, 自動車i_1のルートj_1, 自動車i_2のルートj_2, および自動車i_3のルートj_3が道路セグメントs1を共有する場合, Bs_1={q_i1j1, q_i2j2, q_i3j3}であり, 式(3)は次の形式を取る.
(式4)
一般に, いくつかの道路セグメントを共有する多くの車/ルート変数q_ijが存在する可能性がある.
方程式(3)は, 各バイナリ変数(係数+1)の線形項と２つのバイナリ変数の組み合わせ(係数+2)の二次混合項を与える.
QUBO問題のグローバルコスト関数である式(1)のObjは, 各ストリートセグメントのコスト関数と式(2)の制約を合計することで簡単に説明できる.
(式5)
グローバルコスト関数のコンポーネントを合計する場合, スケーリングパラメーターλを導入する必要がある.
これにより, QUBOの最小の全ての車で式(2)が満たされる.
このスケーリング係数を見つけるには, 式(3)の形式のコスト関数にある車iが存在する最大回数を見つけ, この値をλとして使用する.
これにより, 方程式(2)に違反するコストは, 全てのルートのセグメント占有率を1増やすコストよりも大きくなる.

これで, QUBO問題の必要に応じて, コスト関数を二次上三角行列として定式化できる.
I(q_ij)で与えられるQUBO行列Q(式(1)で定義)のインデックスへのバイナリ変数q_ijのマッピングを保有する.
これらのインデックスは, QUBOマトリックスの対角線である.
行列の要素は, 式(5)のq_ij項の係数である.
これらと用語を明示的に検索するには, ２つのルートjとj'が道路セグメントsを共有する場合には常に:
1. セグメントsを含むルートjで提案された全ての車iの対角インデックスI(q_ij)に(+1)を追加する.
2. インデックスI(q_i1j)で与えれれる非対角要素にセグメントsを含むルートjをとる車i_1とi_2の全てのペアに対して(+2)を追加するおよびI(q_i2j)

次に, 式(2)に従って, 全ての車に１つの流０とのみが含まれるように制約を追加する.
1. 可能なルートjを持つ全ての自動車iについて, インデックスI(q_ij)で与えられるQの対角線に(-λ)を追加する.
2. 式(2)から生じる全てのクロス項について, 対応する非対角項に(2λ)を追加する.

車が１つのルートのみを提案する場合, q_ij=1を意味する特別なケースのみが発生する.
前述のように, ルートiに割り当てれれた車iにも関わらず, この割り当ては他の車に影響を与える.
これにより, 式(3)の二次制約項が追加の線形項に変換される：2qijqi'j '→2qi'j'
さらに, 全てのセグメントが表示されるルートの記録を保持することで, 複数のセグメントで重複するルートがあるため, 冗長な制約を削除できる.

これにより, 図3に示すようにQUBOマトリックスが作成される.

2.3 Summary of the Traffic Flow Optimization Algorithm
擬似コードとして表示された, トラフィックフロー最適化アルゴリズムの重要な高レベルの手順は次のとおりである.
1. 各車iについて：
   a. 現在のルートを決定する.
2. 各車の現在のルート：
   a. ソースから宛先への全ての単純なパスを決定する.
3. 発信元と宛先のペアがある場合：
   a. ソースから宛先への全ての単純なパスを決定する.
   b. 元のルートと相互に最大限に類似していない２つの代替パスを見つける.
4. 各車iについて, QUBOの形式に必要なルートを定義する.
5. セクション2.2の説明に従って, バイナリ変数q_ijを使用して行列Qを定義する.
6.  QUBOの問題を解く.
7. 選択したルートで車を更新する.

3. D-Wave Solvers and Architecture
ここでは, QPUを使用して問題がどのように解決されたかを理解できるよに, D-Waveが提供するソルバートツールを簡単に紹介する.

3.1 Connectivity and Toplogy
D-Wave 2X QPUのトポロジは, 1,152の頂点(量子ビット)と3,000を超える辺(カプラ)を含むC_12キメラグラフに基づいている.
サイズC_Nのキメラグラフは, キメラセル(ユニットタイルまたはユニットセルとも呼ばれる)のN×Nグリッドで, それぞれ8頂点(K_4,4)の完全な二部グラフを含んでいる.
各頂点は, セル内の４つの近傍と, セル外の２つの近傍に接続されている.
したがって, 境界頂点を除く全ての頂点の次数は6である.

418台の車の例では, 1,254個の論理変数を使用して問題を表現した.
このシナリオでの課題は, D-Wave QPUの量子ビット間の接続が制限されていることである. これにより, 任意の構造の問題を直接解く能力が制限される.
D-Wave QPUを直接使用する場合, ２つの問題変数間の相互作用は, これらの変数を表す量子ビット間に物理的な接続(カプラー)がある場合にのみ発生する.
ほとんどの問題では, 変数間の相互作用はQPU接続と一致しない.
この制限では, １つのグラフ構造を別のグラフ構造にマッピングする手法であるマイナー埋め込みを使用して回避できる.
使用したQPUには1,135個の機能量子ビットがあるため, QPUに1,254個の論理変数を一度に埋め込むことはできなかった.
したがって, この問題では, 古典/量子ハイブリッドツールqbsolv(次のセクションで説明)を使用して解かれた.

3.2 The qbsolv Algorithm
2017年1月, D-Wave Systemsはソフトウェアツールqbsolvをオープンソース化した.
このアルゴリズムの目的は, QPUで現在可能であるよりも大きなQUBO問題をより高い接続で解決する機能を提供することができる.
大きなQUBO入力が与えられると, qbsolvは入力を重要なコンポーネントに分割し, QPUへのクエリを使用してコンポーネントを個別に解く.
このプロセスは, ソリューションに改善が見られなくなるまで(タブー検索で見つかった様々なコンポーネントを使用して)繰り返される.
qbsolvアルゴリズムは, 古典的なTabuソルバーを使用するか, D-Wave QPUへの返信を介して, サブ問題を最適化できる.
この論文では, サブ問題をD-Wave 2X QPUに送信する古典/量子ハイブリッドモードでqbsolvを実行する.

ハイブリッドモードでqbsolvによって実行される高レベルの手順は次のとおりである.

1. QPUトポロジ, またはVFYC機能を使用している場合は完全なキメラグラフにマイナー埋め込まれる可能性のある最大のクリークを見つける.
   この一回限りの操作は事前に行うことができる.
2. QUBOの問題が発生した場合, 問題の解決策を表すランダムビット文字列を初期化する.
3. ヒューリスティック手法を使用して, 重要度に従ってノードをランク付けする.
   重要度ランキングを使用して, QPUに適合するサブ問題を作成する.
4. 重要度の順序を使用して, サブ問題を作成する.
5. サブ問題をQPUに送信して解き, ビット文字列の変数状態を更新する.
6. 目的関数の改善が見られなくなるまで, ステップ3〜5を繰り返す.

qbsolvアルゴリズムがどのように機能するかについて詳細な説明は, ブース他で詳しく説明されている.

4. Results
これらの実験の目的は, 実世界の問題を量子アニーリングマシンにマッピングすることでした.
D-Wave QPUによって生成された解を評価するとき, 商店は計算の短い期間内に良質の解を見つけることにあった.
解の品質を定量化するために, 最適化後の混雑した道路の数をカウントする.
ルートは道路セグメントのセットで記述されることに留意して, 指定された回数(N_intersections)より多くルートに表示されるセグメントの数を単純にカウントする.
ここでは, N_intersections以上のルートに表示されるセグメントが混雑すると予想している.
この事件では, N_intersections=10を選択した.

交通流問題のQUBO定式化を評価するために, 次の実験を設計した.
418台のQUBO問題(セクション2.2で説明)について, qbsolvを使用して問題を50回解いた.
また






